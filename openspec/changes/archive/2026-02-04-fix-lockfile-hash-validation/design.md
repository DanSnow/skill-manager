## Context

The install command at `src/cli/install.rs:55-59` has a bug: it uses the lock file unconditionally if it exists, ignoring any changes to `plugins.toml`. Users must manually run `install --update` or delete the lock file to pick up config changes.

The `Manifest` struct uses `HashMap` for marketplaces and plugins, which has non-deterministic iteration order. The lock file is TOML format stored in `src/config/lockfile.rs`.

## Goals / Non-Goals

**Goals:**
- Detect when `plugins.toml` has changed since the lock file was created
- Automatically re-resolve when config changes are detected
- Maintain backward compatibility with existing lock files (missing hash = re-resolve)
- Produce stable, deterministic hashes regardless of HashMap iteration order

**Non-Goals:**
- Changing the `--update` flag behavior (it should still force re-resolution)
- Detecting changes to remote marketplace contents (that's what `--update` is for)
- Supporting incremental updates (we re-resolve everything when config changes)

## Decisions

### Decision 1: Hash algorithm - FxHash via `rustc-hash`

**Choice:** Use `rustc-hash` crate's FxHasher for deterministic hashing.

**Rationale:**
- Rust's `std::hash::DefaultHasher` uses **randomized SipHash keys** - different results each run
- `rustc-hash` provides FxHash: fast, deterministic, same result every time
- Tiny dependency (used by rustc itself), no_std compatible
- We don't need cryptographic properties for config change detection

**Implementation:**
1. Serialize manifest to sorted JSON (via BTreeMap + serde_json)
2. Hash the JSON bytes with FxHasher
3. Store as hex string in lock file

**Alternatives considered:**
- `std::hash::DefaultHasher`: **Not viable** - randomized per run
- `sha2`/`blake3`: Overkill for change detection; adds heavier dependency
- Store raw JSON string: Works but wastes space in lock file; hash is more compact

### Decision 2: Normalization strategy - Sorted JSON serialization

**Choice:** Serialize the manifest to JSON with sorted keys, then hash the JSON string.

**Rationale:**
- JSON serialization with `serde_json` is already available
- Sorting keys at serialization time guarantees deterministic output
- The normalized form captures the semantic content (after GitHub shorthand expansion)

**Implementation:**
1. Create a serializable struct mirroring `Manifest` but with `BTreeMap` instead of `HashMap`
2. Convert `Manifest` → normalized struct (sorts keys automatically)
3. Serialize to JSON with `serde_json::to_string`
4. Hash the JSON string

**Alternatives considered:**
- Hash raw TOML file: Would break on whitespace/comment changes that don't affect semantics
- Custom binary serialization: More complex, harder to debug
- Canonical TOML: No standard canonical form exists

### Decision 3: Hash storage location - Top-level field in lock file

**Choice:** Add `config_hash = "<sha256>"` as a top-level field in `plugins.lock`.

**Rationale:** Simple, visible, easy to inspect manually. The lock file already has a flat structure with `[[marketplace]]` and `[[package]]` arrays.

**Example:**
```toml
# DO NOT EDIT - Generated by skill-manager
config_hash = "a1b2c3d4..."

[[marketplace]]
...
```

### Decision 4: Hash comparison logic

**Choice:** Compare hashes in `install.rs` before deciding whether to use locked versions.

**Logic:**
```
if --update flag:
    re-resolve (existing behavior)
else if lock file exists:
    compute current config hash
    if lock file has no hash OR hash differs:
        re-resolve
    else:
        use locked versions
else:
    re-resolve (no lock file)
```

This is backward compatible: old lock files without `config_hash` trigger re-resolution.

## Risks / Trade-offs

**Risk: Hash collision** → FxHash has reasonable collision resistance for non-adversarial inputs. Not a security concern since worst case is unnecessary re-resolution.

**Risk: Serialization format changes break hashes** → If we change how Manifest serializes (e.g., add fields), all hashes become invalid. Mitigation: This is acceptable - it just triggers re-resolution. Document that hash format may change between versions.

**Trade-off: Re-resolution granularity** → We re-resolve everything when any config changes, even if only one plugin was added. Mitigation: Resolution is fast enough that this is acceptable for MVP. Incremental updates are a non-goal.

**Trade-off: New dependency** → Adding `rustc-hash` is minimal (tiny crate, widely used). The hash output is a u64 (16 hex chars) which is sufficient for change detection.

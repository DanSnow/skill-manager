use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

use crate::{Error, Result};

/// Lock file filename.
pub const LOCK_FILENAME: &str = "plugins.lock";

/// Header comment for generated lock files.
const LOCK_HEADER: &str = "# DO NOT EDIT - Generated by skill-manager\n\
                           # This file is auto-generated. To update, run `skill-manager install --update`\n\n";

/// A locked marketplace with resolved commit hash.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct LockedMarketplace {
    pub name: String,
    pub url: String,
    pub commit: String,
}

/// Source type for a plugin.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    Local,
    External,
}

/// A locked package with resolved version information.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct LockedPackage {
    pub name: String,
    pub marketplace: String,
    pub source_type: SourceType,
    pub marketplace_commit: String,
    /// For external plugins, this is the plugin's own commit hash.
    /// For local plugins, this matches marketplace_commit.
    pub plugin_commit: String,
    /// Human-readable version from plugin.json (display only).
    pub resolved_version: String,
}

/// The plugins.lock file structure.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LockFile {
    /// Hash of the manifest content for change detection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config_hash: Option<String>,
    #[serde(default, rename = "marketplace")]
    pub marketplaces: Vec<LockedMarketplace>,
    #[serde(default, rename = "package")]
    pub packages: Vec<LockedPackage>,
    #[serde(skip)]
    pub path: Option<PathBuf>,
}

impl LockFile {
    /// Create a new empty lock file.
    pub fn new() -> Self {
        Self::default()
    }

    /// Get the lock file path for a given manifest path.
    pub fn path_for_manifest(manifest_path: &Path) -> PathBuf {
        manifest_path
            .parent()
            .unwrap_or(Path::new("."))
            .join(LOCK_FILENAME)
    }

    /// Parse a lock file from TOML content.
    pub fn parse(content: &str) -> Result<Self> {
        toml::from_str(content).map_err(|e| Error::LockFileParse(e.to_string()))
    }

    /// Load a lock file from a file path.
    pub fn load(path: &Path) -> Result<Self> {
        let content = std::fs::read_to_string(path).map_err(|e| Error::FileRead {
            path: path.to_path_buf(),
            source: e,
        })?;
        let mut lockfile = Self::parse(&content)?;
        lockfile.path = Some(path.to_path_buf());
        Ok(lockfile)
    }

    /// Load a lock file if it exists.
    pub fn load_if_exists(path: &Path) -> Result<Option<Self>> {
        if path.exists() {
            Ok(Some(Self::load(path)?))
        } else {
            Ok(None)
        }
    }

    /// Serialize to TOML string with header comment.
    pub fn to_string(&self) -> Result<String> {
        let content = toml::to_string_pretty(self).map_err(|e| Error::LockFileParse(e.to_string()))?;
        Ok(format!("{}{}", LOCK_HEADER, content))
    }

    /// Save the lock file to a path.
    pub fn save(&self, path: &Path) -> Result<()> {
        let content = self.to_string()?;
        std::fs::write(path, content).map_err(|e| Error::FileWrite {
            path: path.to_path_buf(),
            source: e,
        })?;
        Ok(())
    }

    /// Find a locked marketplace by name.
    pub fn find_marketplace(&self, name: &str) -> Option<&LockedMarketplace> {
        self.marketplaces.iter().find(|m| m.name == name)
    }

    /// Find a locked package by name.
    pub fn find_package(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.iter().find(|p| p.name == name)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_lock_file() {
        let content = r#"
[[marketplace]]
name = "official"
url = "https://github.com/anthropics/claude-plugins-official.git"
commit = "abc123def456"

[[package]]
name = "typescript-lsp"
marketplace = "official"
source_type = "local"
marketplace_commit = "abc123def456"
plugin_commit = "abc123def456"
resolved_version = "1.0.0"
"#;
        let lockfile = LockFile::parse(content).unwrap();
        assert_eq!(lockfile.marketplaces.len(), 1);
        assert_eq!(lockfile.packages.len(), 1);

        let mp = &lockfile.marketplaces[0];
        assert_eq!(mp.name, "official");
        assert_eq!(mp.commit, "abc123def456");

        let pkg = &lockfile.packages[0];
        assert_eq!(pkg.name, "typescript-lsp");
        assert_eq!(pkg.source_type, SourceType::Local);
    }

    #[test]
    fn test_serialize_lock_file() {
        let lockfile = LockFile {
            config_hash: Some("abc123def456".to_string()),
            marketplaces: vec![LockedMarketplace {
                name: "official".to_string(),
                url: "https://github.com/anthropics/claude-plugins-official.git".to_string(),
                commit: "abc123".to_string(),
            }],
            packages: vec![LockedPackage {
                name: "superpowers".to_string(),
                marketplace: "official".to_string(),
                source_type: SourceType::External,
                marketplace_commit: "abc123".to_string(),
                plugin_commit: "def456".to_string(),
                resolved_version: "4.1.1".to_string(),
            }],
            path: None,
        };

        let content = lockfile.to_string().unwrap();
        assert!(content.starts_with("# DO NOT EDIT"));
        assert!(content.contains("[[marketplace]]"));
        assert!(content.contains("[[package]]"));
    }

    #[test]
    fn test_round_trip() {
        let original = LockFile {
            config_hash: Some("fedcba9876543210".to_string()),
            marketplaces: vec![LockedMarketplace {
                name: "test".to_string(),
                url: "https://example.com/repo.git".to_string(),
                commit: "abc123".to_string(),
            }],
            packages: vec![LockedPackage {
                name: "plugin1".to_string(),
                marketplace: "test".to_string(),
                source_type: SourceType::Local,
                marketplace_commit: "abc123".to_string(),
                plugin_commit: "abc123".to_string(),
                resolved_version: "1.0.0".to_string(),
            }],
            path: None,
        };

        let serialized = original.to_string().unwrap();
        let parsed = LockFile::parse(&serialized).unwrap();

        assert_eq!(original.config_hash, parsed.config_hash);
        assert_eq!(original.marketplaces, parsed.marketplaces);
        assert_eq!(original.packages, parsed.packages);
    }

    #[test]
    fn test_empty_lock_file() {
        let lockfile = LockFile::new();
        let content = lockfile.to_string().unwrap();
        assert!(content.starts_with("# DO NOT EDIT"));

        let parsed = LockFile::parse(&content).unwrap();
        assert!(parsed.marketplaces.is_empty());
        assert!(parsed.packages.is_empty());
    }

    #[test]
    fn test_config_hash_serialization() {
        let lockfile = LockFile {
            config_hash: Some("0123456789abcdef".to_string()),
            marketplaces: vec![],
            packages: vec![],
            path: None,
        };

        let content = lockfile.to_string().unwrap();
        assert!(content.contains("config_hash = \"0123456789abcdef\""));

        let parsed = LockFile::parse(&content).unwrap();
        assert_eq!(parsed.config_hash, Some("0123456789abcdef".to_string()));
    }

    #[test]
    fn test_missing_config_hash_parses_as_none() {
        // Old lock files without config_hash should still parse
        let content = r#"
[[marketplace]]
name = "test"
url = "https://example.com/repo.git"
commit = "abc123"
"#;
        let parsed = LockFile::parse(content).unwrap();
        assert_eq!(parsed.config_hash, None);
    }

    #[test]
    fn test_config_hash_not_serialized_when_none() {
        let lockfile = LockFile {
            config_hash: None,
            marketplaces: vec![],
            packages: vec![],
            path: None,
        };

        let content = lockfile.to_string().unwrap();
        assert!(!content.contains("config_hash"));
    }
}
